<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: /home/jfpoilpret/projects/fast-arduino-lib/dox/tutorial.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/jfpoilpret/projects/fast-arduino-lib/dox/tutorial.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;FastArduino API Tutorial   {#tutorial}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;========================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;This is FastArduino API step-by-step tutorial.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Only the API is covered here: creating and building a project is not described here, you are supposed to know how to do it already.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Using FastArduino API can be learnt step by step in the preferred following order:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Basics:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;1. [gpio &amp; time](@ref gpiotime)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;2. [UART &amp; flash](@ref uartflash)</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;3. [analog input](@ref analoginput)</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;4. [timer](@ref timer)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;5. [real-time timer](@ref rtt)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;6. [PWM](@ref pwm)</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;7. [utilities](@ref utils)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;Advanced:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;1. [watchdog](@ref watchdog)</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;2. [interrupts](@ref interrupts)</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;3. events, scheduler</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;4. power</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;5. SPI devices management</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;6. I2C devices management</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;7. eeprom</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;8. software UART</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Devices:</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;1. SPI</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;2. I2C</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;3. Other devices: sonar, servo, SIPO</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;@anchor gpiotime Basics: gpio &amp; time</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;------------------------------------</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;### Blink example ###</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;Here is a first example of a FastArduino based program:</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;int main()</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    board::init();</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    sei();</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    while (true)</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        led.toggle();</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        time::delay_ms(500);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    }</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    return 0;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;This example can be broken down into several parts:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;This includes the necessary API from FastArduino; in this example, we just use `gpio.h` (all API for digital input/output) and `time.h` (API for busy loop delays).</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;int main()</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    board::init();</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    sei();</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;The next part defines the standard `main()` function as the entry point of the program; first actions in the `main()` should always be to call `board::init()` (important initialization for some specific boards), then sooner or later call `sei()` to enable interrupts again, as interrupts are disabled when `main()` is initially called.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;This line declares and initializes a digital pin variable named `led` as output for the board&#39;s LED (i.e. `D13` on Arduino boards).</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;`board::DigitalPin` is a strong enum class that defines all digital pins **for the current target**, that target must be defined in the compiler command-line.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;The actual type of `led` is `gpio::FastPin&lt;board::Port:PORT_B, 5&gt;` which means &quot;the pin number 5 within port B&quot;; since this type is not easy to declare when you only know the number of the pin you need, `gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE` is used instead, as it maps directly to the right type.</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;`led` is initialized as an output pin, its initial level is `false` (i.e. GND) by default.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    while (true)</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        led.toggle();</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        time::delay_ms(500);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;Then the program enters an endless loop in which, at every iteration:</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;1. It toggles the level of `led` pin (D13 on Arduino) from GND to Vcc or from Vcc to GND</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;2. It delays execution (i.e. it &quot;waits&quot;) for 500 milliseconds</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;This part of the program simply makes your Arduino LED blink at 1Hz frequency!</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;The last part below is never executed (because of the endless loop above) but is necessary to make the compiler happy, as `main()` shall return a value:</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    return 0;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;Congratulation! We have just studied the typical &quot;blink&quot; program.</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;At this point, it is interesting to compare our first program with the equivalent with standard Arduino API:</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;void setup()</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;{</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;void loop()</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;{</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    digitalWrite(LED_BUILTIN, HIGH);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    delay(500);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    digitalWrite(LED_BUILTIN, LOW);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    delay(500);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;Granted that the latter code seems simpler to write! However, it is also simpler to write it wrong, build and upload it to Arduino and only see it not working:</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;#define LED 53</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;void setup()</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;{</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    pinMode(LED, OUTPUT);</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;}</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;void loop()</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;{</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    digitalWrite(LED, HIGH);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    delay(500);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    digitalWrite(LED, LOW);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    delay(500);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;The problem here is that Arduino API accept a simple number when they need a pin, hence it is perfectly possible to pass them the number of a pin that does not exist, as in the faulty code above: this code will compile and upload properly to an Arduino UNO, however it will not work, because pin 53 does not exist!</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;This problem cannot occur with FastArduino as the available pins are stored in a strong enum and it becomes impossible to select a pin that does not exist for the board we target!</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Now, what is really interesting in comparing both working code examples is the size of the built program (measured with UNO as a target, FastArduino project built with AVR Toolchain 3.5.3, Arduino API project built with Arduino IDE 1.8.2):</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;| code size | 928 bytes   | 154 bytes   |</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;| data size | 9 bytes     | 0 byte      |</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;As you probably know, Atmel AVR MCU (and Arduino boards that embed them) are much constrained in code and data size, hence we could say that &quot;every byte counts&quot;. In the table ablove, one easily sees that Arduino API comes cluttered with lots of code and data, even if you don&#39;t need it; on the other hand, FastArduino is highly optimized and will produce code only for what you **do** use.</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;### LED Chaser example ###</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;Now `gpio.h` has more API than just `gpio::FastPin` and `gpio::FastPinType`; it also includes `gpio::FastPort` and `gpio::FastMaskedPort` that allow to manipulate several pins at a time, as long as these pis belong to the same Port of the MCU. This allows size and speed optimizations when having to deal with a group of related pins, e.g. if you want to implement a LED chaser project.</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;With FastArduino, here is a program showing how you could implement a simple 8 LED chaser on UNO:</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;int main()</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    board::init();</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    sei();</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    gpio::FastPort&lt;board::Port::PORT_D&gt; leds{0xFF, 0x00};</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    uint8_t pattern = 0x01;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    while (true)</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        leds.set_PORT(pattern);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        time::delay_ms(250);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        pattern &lt;&lt;= 1;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        if (!pattern) pattern = 0x01;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    return 0;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;}</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;In this example, we selected all pins of the same port to connect the 8 LEDs of our chaser. Concretely on UNO, this is port D, which pins are D0-D7.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;We thus declare and initialize `leds` as a `gpio::FastPort&lt;board::Port::PORT_D&gt;` port, with all pins as output (`0xFF`), with initial level to GND (`0x00`, all LEDs off).</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;Then, we will keep track of the current lit LED through `pattern` byte which each bit represents actually one LED; `pattern` is initialized with `0x01` i.e. D0 should be the first LED to be ON.</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;In the endless loop that follows, we perform the following actions:</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;1. Set all pins values at once to the current value of `pattern`</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;2. Delay execution for 250ms</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;3. Shift the only 1 bit of `pattern` left; note that after 8 shifts, `pattern` will become `0`, hence we need to check against this condition to reset `pattern` to its initial state.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;This should be rather straightforward to understand if you know C or C++.</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;Here is an equivalent example with Arduino API:</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;const byte LED_PINS[] = {0, 1, 2, 3, 4, 5, 6, 7};</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;const byte NUM_LEDS =  sizeof(LED_PINS) / sizeof(LED_PINS[0]);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;void setup()</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    for(byte i = 0; i &lt; NUM_LEDS; i++)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        pinMode(LED_PINS[i], OUTPUT);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;}</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;void loop()</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;{</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    for(byte i = 0; i &lt; NUM_LEDS; i++)</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        digitalWrite(LED_PINS[i], HIGH);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        delay(250);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        digitalWrite(LED_PINS[i], LOW);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;}</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;We see, with Arduino API, that we have to deal with each pin individually, which makes the program source code longer and not necessarily easier to understand.</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;Here is a quick comparison of the sizes for both programs:</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;| code size | 968 bytes   | 168 bytes   |</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;| data size | 17 bytes    | 0 byte      |</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;@anchor uartflash Basics: UART &amp; flash</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;--------------------------------------</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;### Simple Serial Output example ###</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;Although not often necessary in many finished programs, `UART` (for serial communication interface) is often very useful for debugging a program while it is being developed; this is why `UART` is presented now.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;Here is a first simple program showing how to display, with FastArduino API, a simple string to the serial output (for UNO, this is connected to USB):</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;static char output_buffer[OUTPUT_BUFFER_SIZE];</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;REGISTER_UATX_ISR(0)</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;int main()</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;{</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    board::init();</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    sei();</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;   </div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    serial::hard::UATX&lt;board::USART::USART0&gt; uart{output_buffer};</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    uart.register_handler();</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    uart.begin(115200);</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    streams::OutputBuffer out = uart.out();</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    out.puts(&quot;Hello, World!\n&quot;);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    out.flush();</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    return 0;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;}</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;As usual, at first we need to include the proper header (`uart.h`) to use its API.</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;Then, we define a buffer that will be used by the `UART` API to transmit characters to your PC through USB. You may find it cumbersome to do it yourself but it brings a huge advantage: you are the one to decide of the buffer size, whereas in Arduino API, you have no choice. Here, we consider 64 bits to be big enough to store characters that will be transmitted to the PC. How `UART` is using this buffer is not important to you though.</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;Then we *register an ISR* necessary for transmissions to take place; this is done by the `REGISTER_UATX_ISR(0)` macro. Explicit ISR registration is one important design choice of FastArduino: **you** decide which ISR should be registered to do what. This may again seem cumbersome but once again this gives you the benefit to decie what you need, hence build your application the way you want it.</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;The code that follows instantiates a `uart::hard::UATX` object that is using `board::USART::USART0` (the only one available on UNO) and based on the previously created buffer. Note that `UATX` class is in charge of **only** transmitting characters, not receiving. Other classes exist for only receiving (`UARX`), or for doing both (`UART`).</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;Once created, `uart` needs to be *linked* to the ISR previously registered, this is done through `uart.register_handler()`. Then we can set `uart` ready for transmission, at serial speed of 115200 bps.</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;Next step consists in extracting, from `uart`, a `streams::OutputBuffer` that will allow us to send characters or strings to USB:</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    out.puts(&quot;Hello, World!\n&quot;);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;The last important instruction waits for all characters to be transmitted before leaving the program.</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;Here is the equivalent code with Arduino API:</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;void setup()</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;{</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  Serial.begin(115200);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  Serial.println(&quot;Hello, World!&quot;);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;}</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;void loop()</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;{</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;}</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;Of course, we can see here that the code looks simpler, although one may wonder why we need to define a `loop()` function that does nothing.</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;Now let&#39;s compare the size of both:</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;| code size | 1440 bytes  | 768 bytes   |</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;| data size | 200 bytes   | 93 bytes    |</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;The data size is big because the buffer used by `Serial` has a hard-coded size (you cannot change it without modifying and recompiling Arduino API). Moreover, when using `Serial`, 2 buffers are created, one for input and one for output, even though you may only need the latter one!</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;Now let&#39;s take a look at the 93 bytes of data used in the FastArduino version of this example, how are they broken down?</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;| Source            | data size   |</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;|-------------------|-------------|</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;| `output_buffer`   | 64 bytes    |</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;| power API         | 1 byte      |</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;| `UATX` ISR        | 2 bytes     |</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;| `UATX` vtable     | 10 bytes    |</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;| &quot;Hello, World!\n&quot; | 16 bytes    |</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;| **TOTAL**         | 93 bytes    |</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;*vtable* is specific data created by C++ compiler for classes with `virtual` methods: every time you use virtual methods in classes, this will add more data size, this is why FastArduino avoids `virtual` as much as possible.</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;As you can see in the table above, the constant string `&quot;Hello, World!\n&quot;` occupies 16 bytes of data (i.e. AVR SRAM) in addition to 16 bytes of Flash (as it is part of the program and must eb stored permanently). If your program deals with a lot of constant strings like this, you may quickly meet a memory problem with SRAM usage. This is why it is more effective to keep these strings exclusively in Flash (you have no choice) but load them t SRAM only when they are needed, i.e. when they get printed to `UATX` as in the sample code.</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;How do we change our program so that this string is only stored in Flash? We can use FastArduino `flash` API for that, by changing only one line of code:</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    out.puts(F(&quot;Hello, World!\n&quot;));</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;Note the use of `F()` macro here: this makes the string reside in Flash only, and then it is being read from Flash &quot;on the fly&quot; by `out.puts()` method; the latter method is overloaded for usual C-strings (initial example) and for C-strings stored in Flash only.</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;We can compare the impact on sizes:</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;|           | without %F() | with %F()   |</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;|-----------|--------------|-------------|</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;| code size | 768 bytes    | 776 bytes   |</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;| data size | 93 bytes     | 77 bytes    |</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;Although a bit more code has been added (the code to read the string from Flash into SRAM on the fly), we see 16 bytes have been removed from data, this is the size of the string constant.</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;You may wonder why `&quot;Hello, World!\n&quot;` occupies 16 bytes, although it should use only 15 bytes (if we account for the terminating `&#39;\0&#39;` character); this is because the string is stored in Flash and Flash is word-addressable, not byte-addressable on AVR.</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;Note that Flash can also be used to store other read-only data that you may want to access at runtime at specific times, i.e. data you do not want to be stored permanently on SRAM during all execution of your program.</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;The following example shows how to:</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;- define, in your source code, read-only data that shall be stored in Flash memory</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;- read that data when you need it</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;#include &lt;fastarduino/flash.h&gt;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;// This is the type of data we want to store in flash</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;struct Dummy</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;{</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    uint16_t a;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    uint8_t b;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    bool c;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    int16_t d;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    char e;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;};</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;// Define 2 variables of that type, which will be stored in flash</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;// Note the PROGMEM keyword that says the compiler and linker to put this data to flash</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;const Dummy sample1 PROGMEM = {54321, 123, true, -22222, &#39;z&#39;};</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;const Dummy sample2 PROGMEM = {12345, 231, false, -11111, &#39;A&#39;};</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;// The following function needs value of sample1 to be read from flash</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;void read_and_use_sample1()</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;{</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    // value will get copied with sample1 read-only content</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    Dummy value;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    // request reading sample1 from flash into local variable value</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    flash::read_flash(&amp;sample1, value);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    // Here we can use value which is {54321, 123, true, -22222, &#39;z&#39;}</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;}</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;### Formatted Output example ###</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;Compared to Arduino API, FastArduino brings formatted streams as can be found in standard C++; although more verbose than usual C `printf()` function, formatted streams allow compile-time safety.</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;Here is an example that prints formatted data to USB:</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;static char output_buffer[OUTPUT_BUFFER_SIZE];</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;REGISTER_UATX_ISR(0)</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;int main()</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;{</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    board::init();</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    sei();</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;   </div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    serial::hard::UATX&lt;board::USART::USART0&gt; uart{output_buffer};</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    uart.register_handler();</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    uart.begin(115200);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    streams::FormattedOutput&lt;streams::OutputBuffer&gt; out = uart.fout();</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    uint16_t value = 0x8000;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    out &lt;&lt; F(&quot;value = 0x&quot;) &lt;&lt; hex &lt;&lt; value </div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        &lt;&lt; F(&quot;, &quot;) &lt;&lt; dec &lt;&lt; value </div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        &lt;&lt; F(&quot;, 0&quot;) &lt;&lt; oct &lt;&lt; value </div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        &lt;&lt; F(&quot;, B&quot;) &lt;&lt; bin &lt;&lt; value &lt;&lt; endl;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    return 0;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;}</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;Here, we use `uart.fout()` instead of `uart.out()` to get a `streams::FormattedOutput` on which we can use the &quot;insertion operator&quot; `&lt;&lt;`.</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;If you are used to programming with C++ for more usual systems (e.g. Linux), then you will immediately recognize [`std::ostream` API](http://www.cplusplus.com/reference/ostream/ostream/operator%3C%3C/) which FastArduino library tries to implement with some level of fidelity.</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;You can also find more details in `streams` namespace documentation.</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;Here is the equivalent code with Arduino API:</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;void setup()</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;{</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    Serial.begin(115200);</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    byte value = 0x8000;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    Serial.print(F(&quot;value = 0x&quot;));</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    Serial.print(value, 16);</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    Serial.print(F(&quot;, &quot;));</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    Serial.print(value);</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    Serial.print(F(&quot;, 0&quot;));</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    Serial.print(value, 8);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    Serial.print(F(&quot;, B&quot;));</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    Serial.println(value, 2);</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;}</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;void loop()</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;{</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;}</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;Once again, we can compare the size of both:</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;| code size | 1808 bytes  | 1412 bytes  |</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;| data size | 186 bytes   | 77 bytes    |</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;### Serial Input example ###</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;FastArduino also implements input streams connected to serial output; here is a simple example:</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;static constexpr const uint8_t INPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;static char input_buffer[INPUT_BUFFER_SIZE];</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;REGISTER_UARX_ISR(0)</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;int main()</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;{</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    board::init();</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    sei();</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;   </div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    serial::hard::UARX&lt;board::USART::USART0&gt; uart{input_buffer};</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    uart.register_handler();</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    uart.begin(115200);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    streams::InputBuffer in = uart.in();</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    // Get one character if any</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    int input = in.get();</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    if (input != InputBuffer:EOF)</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    {</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        char value = char(input);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    }</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    // Wait until a character is ready and get it</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    char value = streams::get(in);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    // Wait until a complete string is ready and get it</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    char str[64+1];</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    int len = streams::gets(in, str, 64);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    return 0;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;}</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;Note the similarities between this example and UATX example above for all the setup parts.</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;The main differences are:</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;- use `UARX` type instead of `UATX`</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;- `REGISTER_UARX_ISR()` instead of `REGISTER_UATX_ISR()` macro for ISR registration</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;- use `InputBuffer` instead of `OutputBuffer` and `uart.in()` instead of `uart.out()`</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;Then `UARX` mainly offers one method, `get()`, which returns the next character serially received and buffered; if the input buffer is currently empty, then `get()` returns `InputBuffer::EOF`, which must be tested before dealing with the returned value.</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;Then the example uses 2 functions defined directly within `streams` namespace:</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;- `get()`: this is similar to `InputBuffer.get()` except that it **blocks** until one character is available on serial input.</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;- `gets()`: this blocks until a complete string (terminated by `&#39;\0&#39;`) gets read on serial input and fills the given buffer parameter with that string content.</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;Note that these 2 functions use `time::yield()` while waiting; this may be linked to `power` management. Please take a look at the documentation for this API for further details.</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;### Formatted Input example ###</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;Similar to output, input streams supports formatted input, as can be found in standard C++; once again, formatted input streams allow compile-time safety.</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;The following example uses formatted input to read values from USB:</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;// Define vectors we need in the example</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;REGISTER_UARX_ISR(0)</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;// Buffers for UARX</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;static const uint8_t INPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;static char input_buffer[INPUT_BUFFER_SIZE];</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;using INPUT = streams::FormattedInput&lt;streams::InputBuffer&gt;;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;int main()</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;{</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    board::init();</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    sei();</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;   </div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    // Start UART</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    serial::hard::UARX&lt;board::USART::USART0&gt; uarx{input_buffer};</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    uarx.register_handler();</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    uarx.begin(115200);</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    INPUT in = uarx.fin();</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    // Wait for a char</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    char value1;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    in &gt;&gt; streams::skipws &gt;&gt; value1;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    // Wait for an uint16_t</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    uint16_t value2;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    in &gt;&gt; streams::skipws &gt;&gt; value2;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    return 0;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;}</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;Here, we use `uart.fin()` instead of `uart.in()` to get a `streams::FormattedInput` on which we can use the &quot;extraction operator&quot; `&gt;&gt;`. All extractions are blocking and will not return until the required type can be read from the buffer.</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;If you are used to programming with C++ for more usual systems (e.g. Linux), then you will immediately recognize [`std::istream` API](http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/) which FastArduino library tries to implement with some level of fidelity.</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;You can also find more details in `streams` namespace documentation.</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;We have already seen `UATX` and `UARX` as classes for sending, resp. receiving, data through serial. There is also `UARX` which combines both.</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;As you know, the number of physical (hardware) UART available on an MCU target is limited, some targets (ATtiny) don&#39;t even have any hardware UART at all. For this reason, if you need extra UART featurs to connect to some devices, you can use software UART API, documented in [namespace `serial::soft`](TODO). As this more complicated to use, it is not part of this basic tutorial, but will be addressed later on.</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;@anchor analoginput Basics: analog input</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;----------------------------------------</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;Here is a simple example using analog input API to read a value from some sensor (thermistor, potentiometer, whatever you like) and lights a LED if the read value is above some threshold:</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;#include &lt;fastarduino/analog_input.h&gt;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;const uint16_t THRESHOLD = 500;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;int main()</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;{</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    board::init();</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    sei();</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    analog::AnalogInput&lt;board::AnalogPin::A0&gt; sensor;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    while (true)</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        if (sensor.sample() &gt; THRESHOLD)</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;            led.set();</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        else</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            led.clear();</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        time::delay_ms(100);</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    }</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    return 0;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;}</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;This example is an adaptation of the [first GPIO example](@ref gpio) of this tutorial.</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;The first change consists in including the necessary header:</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;#include &lt;fastarduino/analog_input.h&gt;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;Then we have the definition of the `sensor` variable:</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    analog::AnalogInput&lt;board::AnalogPin::A0&gt; sensor;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;Here we instantiate `AnalogInput` for analog pin `A0` (on Arduino UNO).</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;In the infinite loop, we then get the current analog value of `sensor` and compare it to `THRESHOLD` constant:</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        if (sensor.sample() &gt; THRESHOLD)</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;By default, sample values are on 10 bits (0..1023) represented as `uint16_t`.</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;If you don&#39;t need such precision, you can define `sensor` differently:</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    analog::AnalogInput&lt;board::AnalogPin::A0, board::AnalogReference::AVCC, uint8_t&gt; sensor;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;Note the two additional template arguments provided to `AnalogInput&lt;...&gt;`:</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;- the first added argument `board::AnalogReference::AVCC`, although seldom changed, may become important when you create your own boards from MCU chips; you can further read API documentation if you need more information about it</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;- the second added argument is the type of returned samples, either `uint16_t` (default value) or `uint8_t`. The type determines the samples precision:</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    - `uint8_t`: 8 bits (samples between 0 and 255)</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    - `uint16_t`: 10 bits (samples between 0 and 1023)</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;Now let&#39;s compare the first example with the equivalent Arduino core API program:</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;void setup()</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;{</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;}</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;const uint16_t THRESHOLD = 500;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;void loop()</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;{</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    if (analogRead(A0) &gt; THRESHOLD)</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        digitalWrite(LED_BUILTIN, HIGH);</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    else</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;        digitalWrite(LED_BUILTIN, LOW);</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    delay(100);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;}</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;As usual, we compare the size of both:</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;| code size | 926 bytes   | 204 bytes   |</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;| data size | 9 bytes     | 0 bytes     |</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;Note that Arduino core API does not allow you any other precision than 10 bits.</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;@anchor timer Basics: timer</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;---------------------------</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;A timer (it should actually be named &quot;timer/counter&quot;) is a logic chip or part of an MCU that just &quot;counts&quot; pulses of a clock at a given frequency. It can have several modes. It is used in many occasions such as:</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;- real time counting</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;- asynchronous tasks (one-shot or periodic) scheduling</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;- PWM signal generation (see [PWM](@ref pwm) for further details)</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;A timer generally counts up, but it may also, on some occasions, count down; it may trigger interrupts on several events (i.e. when counter reaches some specific limits), it may drive some specific digital output pins, and sometimes it may also be driven by digital input pins (to capture counter value).</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;There are typically several independent timers on an MCU, but they are not all the same. Timers may differ in:</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;- counter size (8 or 16 bits for AVR timers)</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;- list of settable frequencies (timer frequencies are derived from the MCU clock by prescaler devices)</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;- the timer modes supported</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;- the pins they are connected to</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;- specific capabilities they may have</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;Rather than explaining the theory further, we will start studying a simple example that uses a timer for blinking a LED, a little bit like the first example in this tutorial, but totally driven asynchronously:</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;#include &lt;fastarduino/timer.h&gt;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;constexpr const board::Timer TIMER = board::Timer::TIMER1;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;using CALCULATOR = timer::Calculator&lt;TIMER&gt;;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;using TIMER_TYPE = timer::Timer&lt;TIMER&gt;;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;constexpr const uint32_t PERIOD_US = 1000000;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;constexpr const TIMER_TYPE::TIMER_PRESCALER PRESCALER = CALCULATOR::CTC_prescaler(PERIOD_US);</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;constexpr const TIMER_TYPE::TIMER_TYPE COUNTER = CALCULATOR::CTC_counter(PRESCALER, PERIOD_US);</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;class Handler</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;{</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;public:</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;   Handler(): _led{gpio::PinMode::OUTPUT, false} {}</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;   </div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;   void on_timer()</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;   {</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;       _led.toggle();</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;   }</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;   </div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;private:</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;   gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE _led;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;};</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;// Define vectors we need in the example</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;REGISTER_TIMER_COMPARE_ISR_METHOD(1, Handler, &amp;Handler::on_timer)</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;int main() __attribute__((OS_main));</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;int main()</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;{</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;   board::init();</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;   sei();</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;   Handler handler;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;   interrupt::register_handler(handler);</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;   TIMER_TYPE timer{timer::TimerMode::CTC, PRESCALER, timer::TimerInterrupt::OUTPUT_COMPARE_A};</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;   timer.begin(COUNTER);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;   </div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;   while (true) ;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;}</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;This example looks much more complex than all previous examples but it is straightforward to understand once explained part after part.</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;#include &lt;fastarduino/timer.h&gt;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;In addition to GPIO, we include the header containing all Timer API.</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;For this example, we use Arduino UNO, which MCU (ATmega328P) includes 3 timers (named respectively `Timer0`, `Timer1`, `Timer2` in its datasheet), we use Timer1 which is 16-bits in size:</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;constexpr const board::Timer TIMER = board::Timer::TIMER1;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;using CALCULATOR = timer::Calculator&lt;TIMER&gt;;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;using TIMER_TYPE = timer::Timer&lt;TIMER&gt;;</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;constexpr const uint32_t PERIOD_US = 1000000;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;Although not needed, it is a good practice to define a `const`, named `TIMER` in this snippet, valued with the real timer we intend to use.</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;Then we define 2 new type aliases, `CALCULATOR` and `TIMER` that will help us type less code (this is common recommended practice when using C++ templates heavily in programs):</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;- `CALCULATOR` is the type of a class which provides `static` utility methods that will help us configure the timer we have selected; do note that, since all timers are different, `CALCULATOR` is specific to one timer only; hence if our program was using 2 distinct timers, we would have to define two distinct calculator type aliases, one for each timer.</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;- `TIMER_TYPE` is the type of the class that embed all timer API for the specific timer we have selected.</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;Finally we define `PERIOD_US` the period, in microseconds, at which we want the LED to blink. Please note that this is in fact half the actual period, because this is the time at which we will toggle the LED light.</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;constexpr const TIMER_TYPE::TIMER_PRESCALER PRESCALER = CALCULATOR::CTC_prescaler(PERIOD_US);</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;constexpr const TIMER_TYPE::TIMER_TYPE COUNTER = CALCULATOR::CTC_counter(PRESCALER, PERIOD_US);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;The above snippet defines constant settings, computed by `CALCULATOR` utility class, that we will later use to initialize our timer:</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;- `PRESCALER` is the **optimum** prescaler value that we can use for our timer in order to be able to count up to the requested period, i.e. 1 second; the type of prescaler is an `enum` that depends on each timer (because the list of available prescaler values differ from one timer to another). The prescaler defines the number by which the MCU clock frequency will be divided to provide the pulses used to increment the timer. We don&#39;t need to know this value or fix it ourselves because `CALCULATOR::CTC_prescaler` calculates the best choice for us.</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;- `COUNTER` is the maximum counter value that the timer can reach until 1 second has ellapsed; its type is based on the timer we have selected (i.e. `Timer1` =&gt; 16 bits =&gt; `uint16_t`), but we don&#39;t need to fix this type ourselves because it depends on the timer we have selected.</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;Note that, although we know in advance which timer we use, we always avoid declaring direct types (such as `uint16_t`) in order to facilate a potential change to another timer in the future, without having to change several code locations. </div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;class Handler</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;{</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;public:</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;   Handler(): _led{gpio::PinMode::OUTPUT, false} {}</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;   </div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;   void on_timer()</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;   {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;       _led.toggle();</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;   }</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;   </div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;private:</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;   gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE _led;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;};</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;Here we define the class which implements the code in charge of blinking the LED every time the timer has reached its maximum value, i.e. every second.</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;There is nothing special to explain here, except that the method `on_timer()` is a *callback function* which will get called asynchronously (from interrupt handlers) when the timer reaches its max.</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;Since timers generate interruptions, we need to &quot;attach&quot; our handler code above to the suitable interruption, this is done through the following line of code:</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;REGISTER_TIMER_COMPARE_ISR_METHOD(1, Handler, &amp;Handler::on_timer)</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;`REGISTER_TIMER_COMPARE_ISR_METHOD` is a macro that will generate extra code (code you do not need, nor want, to see) to declare the Interrupt Service Routine (*ISR*) attached to the proper interruption of our selected timer; it takes 3 arguments:</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;- `1` is the timer number (`0`, `1` or `2` on UNO)</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;- `Handler` is the class that contains the code to be called when the interrupt occurs</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;- `&amp;Handler::on_timer` is the Pointer to Member Function (often abbreviated *PTMF* by usual C++ developers) telling which method from `Handler` shall be called back when the interrupt occurs</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;In FastArduino, interrupt handling follows some patterns that are further described [here](TODO) and won&#39;t be developed in detail now.</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;Now we can finally start writing the code of the `main()` function:</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;int main() __attribute__((OS_main));</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;int main()</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;{</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;   board::init();</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;   sei();</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;   Handler handler;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;   interrupt::register_handler(handler);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;Past the usual initialization stuff, this code performs an important task regarding interrupt handling: it creates `handler`, an instance of the `Handler` class that has been defined before as the class to handle interrupts for the selected timer, and then it **registers** this handler instance with FastArduino. Now we are sure that interrupts for our timer will call `handler.on_timer()`.</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;Do note the specific `main` declaration line before its definition: `int main() __attribute__((OS_main));`. This helps the compiler perform some optimization on this function, and may avoid generating several dozens code instructions in some circumstances. In some situations though, this may increase code size by a few bytes; for your own programs, you would have to compile with and without this line if you want to find what is the best for you.</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;The last part of the code creates and starts the timer we need in our program:</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;   TIMER_TYPE timer{timer::TimerMode::CTC, PRESCALER, timer::TimerInterrupt::OUTPUT_COMPARE_A};</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;   timer.begin(COUNTER);</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;   </div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;   while (true) ;</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;}</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;`timer` is the instance of `timer::Timer` API for `board::Timer::TIMER1`; upon instantiation, it is passed the timer mode to use, the previously calculated clock prescaler, and the interrupt we want to enable.</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;Here we use *CTC* mode (Clear Timer on Compare); in this mode the counter is incremented until it reaches a maximum value, then it triggers an interrupt and it clears the counter value back to zero and starts counting up again.</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;To ensure that our handler to get called back when the timer reaches 1 second, we set `timer::TimerInterrupt::OUTPUT_COMPARE_A`, which enables the proper interrupt on this timer: when the counter is reached, an interrupt will occur, the properly registered ISR will be called, and in turn it will call our handler.</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;Then `timer.begin()` activates the timer with the maximum counter value, that was calculated initially in the program. This value, along with `PRESCALER`, has been calculated in order for `timer` to generate an interrupt (i.e. call `handler.on_timer()`) every second.</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;Note the infinite loop `while (true);` at the end of `main()`: without it the program would terminate immediately, giving no chance to our timer and handler to operate as expected. What is interesting to see here is that the main code does not do anything besides looping forever: all actual stuff happens asynchronously behind the scenes!</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;I would have liked to perform a size comparison with Arduino API, but unfortunately, the basic Arduino API does not provide an equivalent way to directly access a timer, hence we cannot produce the equivalent code here. Anyway, here is the size for the example above:</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;|           | FastArduino |</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;|-----------|-------------|</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;| code size | 248 bytes   |</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;| data size | 2 bytes     |</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;@anchor rtt Basics: real-time timer </div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;-----------------------------------</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;A real-time timer is primarily a device that tracks time in standard measurements (ms, us).</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;It may be used in various situations such as:</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;- delay program execution for some us or ms</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;- capture the duration of some event with good accuracy</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;- implement timeouts in programs waiting for an event to occur</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;- generate periodic events</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;The simple example that follows illustrates the first use case:</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;#include &lt;fastarduino/realtime_timer.h&gt;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;REGISTER_RTT_ISR(0)</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;const constexpr uint32_t BLINK_DELAY_MS = 500;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;int main()</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;{</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;   board::init();</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;   sei();</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;   timer::RTT&lt;board::Timer::TIMER0&gt; rtt;</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;   rtt.register_rtt_handler();</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;   rtt.begin();</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;   gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;   while (true)</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;   {</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;       led.toggle();</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;       rtt.delay(BLINK_DELAY_MS);</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;   }</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;}</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;This example looks much like the first blinking example in this tutorial, with a few changes.</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;First off, as usual the neceaary header file is included:</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;#include &lt;fastarduino/realtime_timer.h&gt;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;Then we need to register an ISR for the RTT feature to work properly:</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;REGISTER_RTT_ISR(0)</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;Then, in `main()`, after the usual initialization stuff, we create a real-time timer instance, based on AVR UNO Timer0 (8-bits timer), register it with the ISR previously registered with `REGISTER_RTT_ISR(0)` macro, and finally starts it counting time.</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;   timer::RTT&lt;board::Timer::TIMER0&gt; rtt;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;   rtt.register_rtt_handler();</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;   rtt.begin();</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;Finally, we have the usual loop, toogling the LED, and then delay for 10s, using the RTT API: </div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;       rtt.delay(BLINK_DELAY_MS);</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;Let&#39;s examine the size of this program and compare it with the first example of this tutorial, which used `time::delay_ms()`:</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;|           | delay_ms   | RTT::delay  |</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;|-----------|------------|-------------|</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;| code size | 154 bytes  | 404 bytes   |</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;| data size | 0 bytes    | 3 bytes     |</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;As you can see, code and data size is higher here, so what is the point of using `RTT::delay()` instead of `time::delay_ms()`? The answer is **power consumption**:</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;- `time::delay_ms` is a busy loop which requires the MCU to be running during the whole delay, hence consuming &quot;active supply current&quot; (about 15mA for an ATmega328P at 16MHz)</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;- `RTT::delay()` will set the MCU to pre-defined sleep mode and will still continue to operate well under most available sleep modes (this depends on which timer gets used, refer to [AVR datasheet](TODO) for further details); this will alow reduction of supply current, hence power consumption. Current supply will be reduced more or less dramatically according to the selected sleep mode.</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;Another practical use of RTT is to measure the elapsed time between two events. For instance it can be used with an ultrasonic ranging device to measure the duration of an ultrasound wave to do a roundript from the device to an obstacle, then calculate the actual distance in mm. The following snippet shows how it could look like for an HC-SR04 sensor:</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;// Declare 2 pins connected to HC-SR04</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;gpio::FastPinType&lt;board::DigitalPin::D0&gt;::TYPE trigger{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;gpio::FastPinType&lt;board::DigitalPin::D1&gt;::TYPE echo{gpio::PinMode::INPUT};</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;// Declare RTT (note: don&#39;t forget to call REGISTER_RTT_ISR(1) macro in your program)</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;timer::RTT&lt;board::Timer::TIMER1&gt;&amp; rtt;</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;// Send a 10us pulse to the trigger pin</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;trigger.set();</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;time::delay_us(10);</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;trigger.clear();</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;// Wait for echo signal start</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;while (!echo.value()) ;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;// Reset RTT time</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;rtt.millis(0);</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;// Wait for echo signal end</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;while (echo.value()) ;</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;// Read current time</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;time::RTTTime end = rtt.time();</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;// Calculate the echo duration in microseconds</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;uint16_t echo_us = uint16_t(end.millis * 1000UL + end.micros);</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;Note that this snippet is just an example and is not usable as is: it does not include a timeout mechanism to avoid waiting the echo signal forever (which can happen if the ultrasonic wave does not encounter an obstacle within its possible range, i.e. 4 meters). Also, this approach could be improved by making it interrupt-driven (i.e. having interrupts generated when the `echo_pin` changes state).</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;Another interesting use of RTT is to perform some periodic actions. FastArduino implements an events handling mechanism that can be connected to an RTT in order to deliver periodic events. This mechanism is [described later](TODO) in this tutorial.</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;@anchor pwm Basics: PWM </div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;-----------------------</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;PWM (*Pulse Width modulation*) is a technique that can be used to simulate generation of an analog voltage level through a purely digital output. This is done by varying the *duty cycle* of a rectangular pulse wave, i.e. the ratio of &quot;on&quot; time over the wave period.</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;PWM is implemented by MCU through timers.</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;FastArduino includes special support for PWM. The following example demonstrates PWM to increase then decrease the light emitted by a LED:</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;#include &lt;fastarduino/pwm.h&gt;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;static constexpr const board::Timer TIMER = board::Timer::TIMER0;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;using TIMER_TYPE = timer::Timer&lt;TIMER&gt;;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;using CALC = timer::Calculator&lt;TIMER&gt;;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;static constexpr const uint16_t PWM_FREQUENCY = 450;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;static constexpr const TIMER_TYPE::TIMER_PRESCALER PRESCALER = CALC::FastPWM_prescaler(PWM_FREQUENCY);</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;static constexpr const board::DigitalPin LED = board::PWMPin::D6_PD6_OC0A;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;using LED_PWM = analog::PWMOutput&lt;LED&gt;;</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;int main()</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;{</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;   board::init();</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;   sei();</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;   // Initialize timer</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;   TIMER_TYPE timer{timer::TimerMode::FAST_PWM};</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;   timer.begin(PRESCALER);</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;   </div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;   LED_PWM led{timer};</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;   // Loop of samplings</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;   while (true)</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;   {</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;       for (LED_PWM::TYPE duty = 0; duty &lt; LED_PWM::MAX; ++duty)</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;       {</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;           led.set_duty(duty);</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;           time::delay_ms(50);</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;       }</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;       for (LED_PWM::TYPE duty = LED_PWM::MAX; duty &gt; 0; --duty)</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;       {</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;           led.set_duty(duty);</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;           time::delay_ms(50);</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;       }</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;   }</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;   return 0;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;}</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;The program starts by including the header for PWM API; this will automatically include the timer API header too.</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;Then a timer is selected for PWM (note that the choice of a timer imposes the choice of possible pins) and a prescaler value computed for it, based on the PWM frequency we want to use, 450Hz, which is generally good enough for most use cases (dimming a LED, rotating a DC motor...):</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;static constexpr const board::Timer TIMER = board::Timer::TIMER0;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;using TIMER_TYPE = timer::Timer&lt;TIMER&gt;;</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;using CALC = timer::Calculator&lt;TIMER&gt;;</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;static constexpr const uint16_t PWM_FREQUENCY = 450;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;static constexpr const TIMER_TYPE::TIMER_PRESCALER PRESCALER = CALC::FastPWM_prescaler(PWM_FREQUENCY);</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;Then we define the pin that will be connected to the LED and the PWMOutput type for this pin:</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;static constexpr const board::DigitalPin LED = board::PWMPin::D6_PD6_OC0A;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;using LED_PWM = analog::PWMOutput&lt;LED&gt;;</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;Note that `board::PWMPin` namespace limits the pins to PWM-enabled pins; also note the pin name `D6_PD6_OC0A` includes useful information:</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;- this is pin `D6` on Arduino UNO</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;- this pin is on `PD6` i.e. Port D bit #6</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;- this pin is connectable to `OC0A` i.e. Timer 0 COM A</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;Then, in `main()`, after the usual initialization code, we initialize and start the timer:</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;   // Initialize timer</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;   TIMER_TYPE timer{timer::TimerMode::FAST_PWM};</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;   timer.begin(PRESCALER);</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;Notice we use the *Fast PWM* mode here, but we might as well use *Phase Correct PWM* mode.</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;Next we connect the LED pin to the timer:</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;   LED_PWM led{timer};</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;In the main loop, we have 2 consecutive loops, the first increases the light, the second decreases it. Both loops vary the duty cycle between its limits:</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;       for (LED_PWM::TYPE duty = 0; duty &lt; LED_PWM::MAX; ++duty)</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;       {</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;           led.set_duty(duty);</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;           time::delay_ms(50);</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;       }</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;Note the use of `LED_PWM::TYPE`, which depends on the timer selected (8 or 16 bits), and `LED_PWM::MAX` which provides the maximum value usable for the duty cycle, i.e. the value mapping to 100% duty cycle. Pay attention to the fact that `LED_PWM::TYPE` is unsigned, this explains the 2nd loop:</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;       for (LED_PWM::TYPE duty = LED_PWM::MAX; duty &gt; 0; --duty)</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;       {</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;           led.set_duty(duty);</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;           time::delay_ms(50);</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;       }</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;Here, we shall not use `duty &gt;= 0` as the `for` condition, because that condition would be always `true`, hence the loop would be infinite.</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;Now let&#39;s compare this example with the Arduino API equivalent:</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;#define LED 6</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;void setup() {</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;}</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;void loop() {</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;    for (int duty = 0; duty &lt; 255; ++duty)</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;    {</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;        analogWrite(LED, duty);</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;        delay(50);</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    }</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;    for (int duty = 255; duty &gt; 0; --duty)</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    {</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;        analogWrite(LED, duty);</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;        delay(50);</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    }</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;}</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;Nothing special to comment here, except:</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;- `duty` values are always limited to 255 even though some PWM pins are attached to a 16-bits timer</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;- you cannot choose the PWM mode you want to use, it is fixed by Arduino API and varies depending on which timer is used (e.g. for Arduino UNO, Timer0 uses Fast PWM, whereas Time1 and Timer2 use Phase Correct PWM mode)</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;- you cannot choose the PWM frequency, this is imposed to you by Arduino API and varies depending on which timer is used</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;- you may pass any pin value to `analogWrite()` and the sketch will still compile and upload but the sketch will not work</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;Comparing sizes once again shows big differences:</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;| code size | 1302 bytes  | 288 bytes   |</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;| data size | 9 bytes     | 0 byte      |</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;@anchor utils Basics: utilities</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;-------------------------------</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;FastArduino provides several general utilities, gathered inside one namespace `utils`.</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;We will not demonstrate each of these utilities here but just show a few of them in action. In your own programs, if you find yourself in need of some helper stuff that you think deserves to be provided as a general utility, then first take a look at FastArduino [utilities API documentation](namespaceutils.html) and check if you don&#39;t find it there, or something similar that you could use in your situation.</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;FastArduino utilities are made of different kinds:</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;- low-level utilities: mostly functions to handle bytes and bits</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;- value conversion utilities: functions to help convert a value from one referential to another, very useful when dealing with sensors of all sorts</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;### Low-level utilities examples</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;The few examples in this section will introduce you to a few functions that may prove useful if you need to handle devices that are not natively supported by FastArduino.</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;1. `utils::swap_bytes`: this function is useful whenever you use a sensor device that provides you with integer values, coded on 2 bytes, with high byte first and low byte second; since AVR MCU are &quot;little-endian&quot; processors, they expect words in the opposite order: low byte first, high byte second, hence in order to interpret values provided by that device, you need to first swap their bytes. Bytes swap is performed &quot;in-place&quot;, i.e. the original value is replace with the converted value. The following example is an excerpt of `hmc5883l.h` provided by FastArduino, where magnetic fields in 3 axes have to be converted from big endian (as provided by the HMC5883L) to little endian (as expected by the AVR MCU):</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    bool magnetic_fields(MagneticFields&amp; fields)</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;    {</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;        if (   this-&gt;write(DEVICE_ADDRESS, OUTPUT_REG_1, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;            &amp;&amp; this-&gt;read(DEVICE_ADDRESS, fields, i2c::BusConditions::REPEAT_START_STOP) == i2c::Status::OK)</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        {</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;            utils::swap_bytes(fields.x);</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;            utils::swap_bytes(fields.y);</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;            utils::swap_bytes(fields.z);</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;            return true;</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        }</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        else</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;            return false;</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;    }</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;2. `utils::bcd_to_binary`: this function is useful when you use a sensor device that provides values coded as *BCD* (binary-coded decimal), i.e. where each half-byte (*nibble*) contains the value of one digit (i.e. `0` to `9`), thus holding a range of values from `0` to `99`. Many RTC devices use BCD representation for time. In order to performa calculation on BCD values, you need to first convert them to binary. The opposite function is also provided as `utils::binary_to_bcd`. The following example is an excerpt of `ds1307.h` provided by FastArduino, where each datetime field (seconds, minutes, hours...) have to be covnerted from BCD to binary:</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;    bool getDateTime(tm&amp; datetime)</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    {</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;        // send register address to read from (0)</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;        // read datetime at address 0</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;        if (   write(DEVICE_ADDRESS, TIME_ADDRESS, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;            &amp;&amp; read(DEVICE_ADDRESS, datetime, i2c::BusConditions::REPEAT_START_STOP) == i2c::Status::OK)</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;        {</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            // convert DS1307 output (BCD) to integer type</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;            datetime.tm_sec = utils::bcd_to_binary(datetime.tm_sec);</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;            datetime.tm_min = utils::bcd_to_binary(datetime.tm_min);</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;            datetime.tm_hour = utils::bcd_to_binary(datetime.tm_hour);</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;            datetime.tm_mday = utils::bcd_to_binary(datetime.tm_mday);</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;            datetime.tm_mon = utils::bcd_to_binary(datetime.tm_mon);</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;            datetime.tm_year = utils::bcd_to_binary(datetime.tm_year);</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;        }</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;    }</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;### Conversion utilities examples</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;Device sensors measure some physical quantity and generally provide you with some integer value that somehow maps to the physical value. hence to make use of the raw value provided by a sensor, you need to convert it to some more meaningful value that you can understand and operate upon.</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;Or conversely, you may just need to compare the physical value agains some thresholds (e.g. check the gyroscopic speed according to some axis is less than 10°/s), and perform some action when this is not true. In this situation, you don&#39;t really need to convert the raw sensor value into a physical quantity to compare to the physical threshold, but rather convert (once only) the physical threshold into the corresponding raw value (a constant in your program) and then only compare raw values, which is:</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;- more performant (no conversion needed before comparison)</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;- more size efficient (conversion of threshold can be done at compile time, hence no code is generated for it)</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;FastArduino utilities provide several conversion methods between raw and physical quantities, according to raw and physical ranges (known for each sensor), and unit prefix (e.g. kilo, mega, giga, centi, milli...). These methods are `constexpr`, which means that, when provided with constant arguments, they will be evaluated at compile-time and return a value that is itself stored as a constant.</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;1. `utils::map_physical_to_raw`: although it may seem complicated by its list of arguments, this function is actually pretty simple, as demonstrated in the snippet hereafter:</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;   static constexpr const int16_t ACCEL_1 = map_physical_to_raw(500, UnitPrefix::MILLI, 2, 15);</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;In this example, we convert the acceleration value 500mg (g is *9.81 m/s/s*) to the equivalent raw value as produced by an MPU-6050 accelerometer, using *+/-2g* range (`2` is the max physical value we can get with this device using this range) where this raw value is stored on `15 bits` (+1 bit for the sign), i.e. `32767` is the raw value returned by the device when the measured acceleration is `+2g`.</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;2. `utils::map_raw_to_physical`: this method does the exact opposite of `utils::map_physical_to_raw` with the same parameters, reversed:</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;   int16_t rotation = map_raw_to_physical(raw, UnitPrefix::CENTI, 250, 15);</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;In this example, we convert `raw` which is returned by the MPU-6050 gyroscope, using range *+/-250°/s* with `15 bits` precision (+1 bit for the sign), i.e. `32767` is the raw value returned by the device when the measured rotation speed is `+250°/s`. The calculated value is returned in *c°/s* (centi-degrees per second).</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;In addition to these functions, FastArduino utilities also include the more common `utils::map` and `utils::constrain` which work like their Arduino API equivalent `map()` and `constrain()`.</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;@anchor watchdog Advanced: Watchdog</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;-----------------------------------</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;In general, a watchdog is a device (or part of a device) that is used to frequently check that a system is not hanging. AVR MCU include such a device and this can be programmed to other purposes than checking the system is alive, e.g. as a simple timer with low-power consumption. This is in that purpose that FastArduino defines a specific Watchdog API.</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;FastArduino defines 2 watchdog classes. The first one, `WatchdogSignal` allows you to generate watchdog timer interrupts at a given period.</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;The following example is yet another way to blink a LED:</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;#include &lt;fastarduino/power.h&gt;</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;#include &lt;fastarduino/watchdog.h&gt;</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;// Define vectors we need in the example</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;REGISTER_WATCHDOG_ISR_EMPTY()</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;int main() __attribute__((OS_main));</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;int main()</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;{</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;   board::init();</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;   sei();</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;   gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;   watchdog::WatchdogSignal watchdog;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;   watchdog.begin(watchdog::WatchdogSignal::TimeOut::TO_500ms);</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;   </div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;   while (true)</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;   {</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;       led.toggle();</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;       power::Power::sleep(board::SleepMode::POWER_DOWN);</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;   }</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;}</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;In this example, we use `watchdog` API but also `power` API in order to reduce power-consumption.</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;As we use `WatchdogSignal`, we need to register an ISR, however we do not need any callback, hecen we just register an empty ISR.</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;REGISTER_WATCHDOG_ISR_EMPTY()</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;Then we have the usual `main()` function which, after defining `led` output pin, starts the watchdog timer:</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;   watchdog::WatchdogSignal watchdog;</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;   watchdog.begin(watchdog::WatchdogSignal::TimeOut::TO_500ms);</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;Here we use a 500ms timeout period, which means our sleeping code will be awakened every 500ms.</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;The infinite loop just toggles `led` pin level and goes to sleep:</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;   while (true)</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;   {</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;       led.toggle();</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;       power::Power::sleep(board::SleepMode::POWER_DOWN);</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;   }</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;As explained [later](TODO), `power::Power::sleep(board::SleepMode::POWER_DOWN)` just puts the MCU to sleep until some external interrupts wake it up; in our example, that interrupt is the watchdog timeout interrupt. </div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;The size of this example is not much bigger than the first example of this tutorial:</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;|           | FastArduino |</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;|-----------|-------------|</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;| code size | 262 bytes   |</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;| data size | 0 byte      |</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;FastArduino defines another class, `Watchdog`. This class allows to use the AVR watchdog timer as a clock for events generation. This will be demonstrated when [events scheduling](TODO) is described.</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;@anchor interrupts Advanced: Interrupts</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;---------------------------------------</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;TODO ISR and interrupts in AVR brief intro</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;TODO refer to some previous examples REGISTER macro and register_handler</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;TODO general interrupts API/macros and naming conventions for macros</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;TODO specific API macros</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;TODO table of all REGISTER macros</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>tutorial.md</b></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
